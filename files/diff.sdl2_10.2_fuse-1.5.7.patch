By Marc Serdeliuc
https://github.com/serdeliuk

--- a/configure.ac
+++ b/configure.ac
@@ -281,21 +281,66 @@
 if test -z "$UI"; then
   AC_MSG_CHECKING(whether SDL UI requested)
   AC_ARG_WITH(sdl,
-  [  --with-sdl              use SDL for user interface],
+  [  --with-sdl              use SDL for user interface (=1 to force SDL1)],
   if test "$withval" = no; then sdl=no; else sdl=yes; fi,
   sdl=no)
+  if test "$withval" = 1; then sdl1=yes; else sdl1=no; fi
   AC_MSG_RESULT($sdl)
   if test "$sdl" = yes; then
-    SDL_VERSION=1.2.4
-    AM_PATH_SDL($SDL_VERSION,
-		AC_DEFINE([UI_SDL], 1, [Defined if the SDL UI in use])
+    if test "$sdl1" = no; then
+      SDL_VERSION=2.0.0
+      PKG_CHECK_MODULES([SDL2], [sdl2 >= $SDL_VERSION],
+		AC_DEFINE([UI_SDL2], 1, [Defined if the SDL2 UI in use])
 		AC_DEFINE([USE_WIDGET], 1,
 		          [Defined if we're using a widget-based UI])
 		UI=sdl; WIDGET=widget,
+	        UI_LIBS="ui/sdl/libuisdl.a ui/widget/libwidget.a",
+                AC_MSG_RESULT([SDL version $SDL_VERSION not found])
+                SDL_VERSION=1.2.4)
+      if test "$UI" = sdl; then
+	AC_MSG_CHECKING(whether WM aspect hint enabled)
+        AC_ARG_ENABLE(wm-aspect-hint,
+          AS_HELP_STRING([--enable-wm-aspect-hint],[enable WM aspect hint for SDL2 UI (auto x11) [default=auto]]),
+          if test "$enableval" = yes; then wmaspect=auto
+          elif test "$enableval" = no; then wmaspect=no
+          else wmaspect="$enableval"; fi,
+          wmaspect=auto)
+        if test "$wmaspect" = no; then wmtestres="$wmaspect"; else wmtestres="yes ($wmaspect)"; fi
+        AC_MSG_RESULT($wmtestres)
+	if test "$wmaspect" = auto || test "$wmaspect" = x11; then
+	  AC_CHECK_HEADERS( [X11/Xutil.h],
+		AC_DEFINE([USE_WM_ASPECT_X11], 1,
+			[Defined if we're using WM aspect hints])
+		wmaspect=x11; LIBS="$LIBS -lX11",
+		wmaspectnotfound=1
+	  )
+	elif test "$wmaspect" = auto || test "$wmaspect" = osx; then
+	  wmaspectnotfound=1
+	fi
+	if test "$wmaspectnotfound" = 1; then
+	  AC_MSG_RESULT([  ... cannot enable WM aspect hints ($wmaspect)])
+	else
+	  AC_MSG_RESULT([  ... WM aspect hints ($wmaspect) enabled])
+	fi
+      fi
+    else
+      AC_MSG_RESULT([    ... forced to use SDL 1.x.x])
+      SDL_VERSION=1.2.4
+    fi
+    if test "$SDL_VERSION" = "1.2.4"; then
+      AM_PATH_SDL($SDL_VERSION,
+		AC_DEFINE([UI_SDL], 1, [Defined if the SDL UI in use])
+		AC_DEFINE([USE_WIDGET], 1,
+		          [Defined if we're using a widget-based UI])
+		UI=sdl; WIDGET=widget; sdl1=yes
+            UI_LIBS="ui/sdl/libuisdl.a ui/widget/libwidget.a", 
                 AC_MSG_ERROR([SDL version $SDL_VERSION not found]))
+    fi
   fi
 fi
 
+AM_CONDITIONAL(HAVE_SDL2, test "$sdl1" != yes)
+
 dnl Look for null UI (default=no)
 if test -z "$UI"; then
   AC_MSG_CHECKING(whether null UI requested)
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/input.h
+++ b/input.h
@@ -78,9 +78,9 @@
   INPUT_KEY_equal,
   INPUT_KEY_greater,
   INPUT_KEY_question,
-  INPUT_KEY_at,
 
-  INPUT_KEY_A = 0x41,
+  INPUT_KEY_at = 0x40,
+  INPUT_KEY_A,
   INPUT_KEY_B,
   INPUT_KEY_C,
   INPUT_KEY_D,
@@ -112,6 +112,7 @@
   INPUT_KEY_asciicircum = 0x5e,
   INPUT_KEY_dead_circumflex = 0x5e,
   INPUT_KEY_underscore = 0x5f,
+  INPUT_KEY_quoteleft,
 
   INPUT_KEY_a = 0x61,
   INPUT_KEY_b,
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/keysyms.dat
+++ b/keysyms.dat
@@ -99,6 +99,7 @@
 asciicircum
 dead_circumflex
 underscore
+quoteleft
 
 a
 b
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/keysyms.pl
+++ b/keysyms.pl
@@ -136,6 +136,11 @@
     wii => { headers => [ 'ui/wii/wiikeysyms.h' ],
 	      max_length => 24,
 	      skips => { map { $_ => 1 } ( 'numbersign',
+					   'at', 'asciitilde',
+                                           'quotedbl', 'question',
+                                           'underscore', 'braceleft',
+                                           'braceright','quoteleft',
+                                           'bracketleft', 'bracketright',
 					   'Shift_L', 'Shift_R',
 					   'Control_L', 'Control_R',
 					   'Alt_L', 'Alt_R',
@@ -154,11 +159,11 @@
 	      function => sub ($) { "GDK_KEY_$_[0]" },
     	    },
 
-    sdl  => { headers => [ 'SDL.h' ],
+    sdl  => { headers => [ 'SDL.h', 'ui/sdl/sdl2keyboard.h' ],
 	      max_length => 18,
 	      skips => { map { $_ => 1 } ( 'Hyper_L','Hyper_R','Caps_Lock',
-                         'A' .. 'Z', 'asciitilde', 'bar', 'dead_circumflex',
-                         'braceleft', 'braceright', 'percent' ) },
+                         'A' .. 'Z', 'bar', 'percent', 'dead_circumflex',
+                         'braceleft', 'braceright', 'asciitilde' ) },
 	      unicode_skips => { map { $_ => 1 } qw( Hyper_L Hyper_R Caps_Lock
                          Escape F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12
                          BackSpace Tab Caps_Lock Return Shift_L Shift_R
@@ -181,12 +186,16 @@
 		  Page_Down   => 'PAGEDOWN',
 		  parenleft   => 'LEFTPAREN',
 		  parenright  => 'RIGHTPAREN',
+		  quoteleft   => 'BACKQUOTE',
+		  asciitilde  => 'TILDE',
 	      },
 	      unicode_translations => {
                   space       => ' ',
                   exclam      => '!',
+                  quotedbl    => '"',
                   dollar      => '$',
                   numbersign  => '#',
+                  percent     => '%',
                   ampersand   => "&",
                   apostrophe  => "'",
                   asciitilde  => "~",
@@ -207,6 +216,7 @@
                   minus       => '-',
                   period      => '.',
                   slash       => '/',
+                  question    => '?',
                   colon       => ':',
                   semicolon   => ';',
                   less        => '<',
@@ -215,6 +225,7 @@
                   asciicircum => '^',
                   bar         => '|',
                   underscore  => '_',
+                  quoteleft   => '`',
 	      },
 	      function => \&sdl_keysym,
 	      unicode_function => \&sdl_unicode_keysym,
@@ -223,8 +234,10 @@
     svga => { headers => [ 'vgakeyboard.h' ],
 	      max_length => 26,
 	      skips => { map { $_ => 1 } qw( Hyper_L Hyper_R Super_L Super_R
-                 dollar less greater exclam ampersand parenleft parenright
-                 asterisk plus colon asciicircum dead_circumflex bar ) },
+                 dollar less greater exclam percent ampersand parenleft parenright
+                 asterisk at plus colon asciicircum asciitilde dead_circumflex bar 
+                 quotedbl question underscore braceleft braceright quoteleft 
+                 bracketleft bracketright ) },
 	      translations => {
 		  Caps_Lock  => 'CAPSLOCK',
 		  numbersign => 'BACKSLASH',
@@ -259,7 +272,7 @@
 					   'braceleft','braceright','bracketleft','bracketright',
 					   'apostrophe','asciicircum','dead_circumflex','asciitilde',
 					   'at','backslash','comma','equal','minus','numbersign',
-					   'percent','period','question','quotedbl',
+					   'percent','period','question','quotedbl','quoteleft',
 					   'semicolon','slash','underscore',
 					   'A' .. 'Z' ) },
 	      translations => { 
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/m4/sdl2.m4
+++ b/m4/sdl2.m4
@@ -0,0 +1,181 @@
+# By Marc Serdeliuc
+# https://github.com/serdeliuk/MS-ZX80
+# 20 Apr 2020
+
+# Configure paths for SDL2
+# Sam Lantinga 9/21/99
+# stolen from Manish Singh
+# stolen back from Frank Belew
+# stolen from Manish Singh
+# Shamelessly stolen from Owen Taylor
+
+# Taken from SDL2 1.2.7 by PAK 2004/07/07
+
+dnl AM_PATH_SDL2([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for SDL2, and define SDL2_CFLAGS and SDL2_LIBS
+dnl
+AC_DEFUN([AM_PATH_SDL2],
+[dnl 
+dnl Get the cflags and libraries from the sdl-config script
+dnl
+AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL2 is installed (optional)],
+            sdl_prefix="$withval", sdl_prefix="")
+AC_ARG_WITH(sdl-exec-prefix,[  --with-sdl-exec-prefix=PFX Exec prefix where SDL2 is installed (optional)],
+            sdl_exec_prefix="$withval", sdl_exec_prefix="")
+AC_ARG_ENABLE(sdltest, [  --disable-sdltest       Do not try to compile and run a test SDL2 program],
+		    , enable_sdltest=yes)
+
+  if test x$sdl_exec_prefix != x ; then
+     sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
+     if test x${SDL2_CONFIG+set} != xset ; then
+        SDL2_CONFIG=$sdl_exec_prefix/bin/pkg-config
+     fi
+  fi
+  if test x$sdl_prefix != x ; then
+     sdl_args="$sdl_args --prefix=$sdl_prefix"
+     if test x${SDL2_CONFIG+set} != xset ; then
+        SDL2_CONFIG=$sdl_prefix/bin/pkg-config
+     fi
+  fi
+
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  PATH="$prefix/bin:$prefix/usr/bin:$PATH"
+  AC_PATH_PROG(SDL2_CONFIG, pkg-config, no, [$PATH])
+  min_sdl_version=ifelse([$1], ,0.11.0,$1)
+  AC_MSG_CHECKING(for SDL2 - version >= $min_sdl_version)
+  no_sdl=""
+  if test "$SDL2_CONFIG" = "no" ; then
+    no_sdl=yes
+  else
+    SDL2_CFLAGS=`$SDL2_CONFIG sdl2 --cflags`
+    SDL2_LIBS=`$SDL2_CONFIG sdl2 --libs`
+
+    sdl_major_version=`$SDL2_CONFIG sdl2 --modversion | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    sdl_minor_version=`$SDL2_CONFIG sdl2 --modversion | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    sdl_micro_version=`$SDL2_CONFIG sdl2 --modversion | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x$enable_sdltest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $SDL2_CFLAGS"
+      LIBS="$LIBS $SDL2_LIBS"
+dnl
+dnl Now check if the installed SDL2 is sufficiently new. (Also sanity
+dnl checks the results of sdl-config to some extent
+dnl
+      rm -f conf.sdltest
+      AC_TRY_RUN([
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <SDL.h>
+
+char*
+my_strdup (char *str)
+{
+  char *new_str;
+  
+  if (str)
+    {
+      new_str = (char *)malloc ((strlen (str) + 1) * sizeof(char));
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+  
+  return new_str;
+}
+
+int main (int argc, char *argv[])
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  /* This hangs on some systems (?)
+  system ("touch conf.sdltest");
+  */
+  { FILE *fp = fopen("conf.sdltest", "a"); if ( fp ) fclose(fp); }
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = my_strdup("$min_sdl_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_sdl_version");
+     exit(1);
+   }
+
+   if (($sdl_major_version > major) ||
+      (($sdl_major_version == major) && ($sdl_minor_version > minor)) ||
+      (($sdl_major_version == major) && ($sdl_minor_version == minor) && ($sdl_micro_version >= micro)))
+    {
+      return 0;
+    }
+  else
+    {
+      printf("\n*** 'pkg-config sdl2 --modversion' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
+      printf("*** of SDL2 required is %d.%d.%d. If pkg-config is correct, then it is\n", major, minor, micro);
+      printf("*** best to upgrade to the required version.\n");
+      printf("*** If pkg-config was wrong, set the environment variable SDL2_CONFIG\n");
+      printf("*** to point to the correct copy of pkg-config, and remove the file\n");
+      printf("*** config.cache before re-running configure\n");
+      return 1;
+    }
+}
+
+],, no_sdl=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_sdl" = x ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$2], , :, [$2])     
+  else
+     AC_MSG_RESULT(no)
+     if test "$SDL2_CONFIG" = "no" ; then
+       echo "*** The pkg-config script installed by SDL2 could not be found"
+       echo "*** If SDL2 was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the SDL2_CONFIG environment variable to the"
+       echo "*** full path to pkg-config."
+     else
+       if test -f conf.sdltest ; then
+        :
+       else
+          echo "*** Could not run SDL2 test program, checking why..."
+          CFLAGS="$CFLAGS $SDL2_CFLAGS"
+          LIBS="$LIBS $SDL2_LIBS"
+          AC_TRY_LINK([
+#include <stdio.h>
+#include "SDL2.h"
+
+int main(int argc, char *argv[])
+{ return 0; }
+#undef  main
+#define main K_and_R_C_main
+],      [ return 0; ],
+        [ echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding SDL2 or finding the wrong"
+          echo "*** version of SDL2. If it is not finding SDL2, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
+        [ echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means SDL2 was incorrectly installed"
+          echo "*** or that you have moved SDL2 since it was installed. In the latter case, you"
+          echo "*** may want to edit the sdl-config script: $SDL2_CONFIG" ])
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     SDL2_CFLAGS=""
+     SDL2_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(SDL2_CFLAGS)
+  AC_SUBST(SDL2_LIBS)
+  rm -f conf.sdltest
+])
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/Makefile.am
+++ b/Makefile.am
@@ -63,6 +63,7 @@
              $(GLIB_LIBS) \
              $(PNG_LIBS) \
              $(SDL_LIBS) \
+	     $(SDL2_LIBS) \
              $(X_LIBS) \
              $(XML_LIBS)
 
@@ -87,6 +88,7 @@
               $(LIBSPECTRUM_CFLAGS) \
               $(XML_CFLAGS) \
               -DFUSEDATADIR="\"${pkgdatadir}\"" \
+	      $(SDL2_CFLAGS) \
               $(SDL_CFLAGS) \
               $(PNG_CFLAGS)
 
@@ -137,6 +139,7 @@
 	     m4/gtk-2.0.m4 \
 	     m4/pkg.m4 \
 	     m4/sdl.m4 \
+	     m4/sdl2.m4 \
 	     menu_data.dat \
 	     menu_data.pl \
 	     settings.dat \
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/settings.dat
+++ b/settings.dat
@@ -282,3 +282,7 @@
 disk_ask_merge, boolean, 1
 
 debugger_command, string, NULL
+
+#ifdef UI_SDL2
+sdl_scale_quality, string, NULL
+#endif
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/options.dat
+++ b/ui/options.dat
@@ -17,6 +17,9 @@
 #ifdef UI_SDL
 Checkbox, Full (s)creen, full_screen, INPUT_KEY_s
 #endif
+#ifdef UI_SDL2
+Checkbox, Full (s)creen, full_screen, INPUT_KEY_s
+#endif
 Checkbox, Show status(b)ar, statusbar, INPUT_KEY_b
 Checkbox, Snap (j)oystick prompt, joy_prompt, INPUT_KEY_j
 Checkbox, (C)onfirm actions, confirm_actions, INPUT_KEY_c
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/Makefile.am
+++ b/ui/sdl/Makefile.am
@@ -32,7 +32,6 @@
 CLEANFILES += $(ui_sdl_built)
 
 ui_sdl_files = \
-               ui/sdl/sdldisplay.c \
                ui/sdl/sdldisplay.h \
                ui/sdl/sdljoystick.c \
                ui/sdl/sdljoystick.h \
@@ -41,6 +40,13 @@
                ui/sdl/sdlui.c \
                ui/sdl/keysyms.c
 
+
+if HAVE_SDL2
+    ui_sdl_files += ui/sdl/sdl2display.c
+else
+    ui_sdl_files += ui/sdl/sdldisplay.c
+endif
+
 ui_sdl_built = ui/sdl/keysyms.c
 
 ui/sdl/keysyms.c: $(srcdir)/keysyms.pl $(srcdir)/keysyms.dat
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdl2display.c
+++ b/ui/sdl/sdl2display.c
@@ -0,0 +1,851 @@
+/* sdldisplay.c: Routines for dealing with the SDL display
+   Copyright (c) 2000-2006 Philip Kendall, Matan Ziv-Av, Fredrick Meunier
+   Copyright (c) 2014 Gergely Szasz
+
+   $Id: $
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   E-mail: szaszg@hu.inter.net
+
+*/
+
+#include <config.h>
+
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <SDL.h>
+
+#ifdef USE_WM_ASPECT_X11
+#include <X11/Xutil.h>
+#include <SDL_syswm.h>
+#endif
+
+#include <libspectrum.h>
+
+#include "display.h"
+#include "fuse.h"
+#include "machine.h"
+#include "peripherals/scld.h"
+#include "screenshot.h"
+#include "settings.h"
+#include "ui/ui.h"
+#include "ui/scaler/scaler.h"
+#include "ui/uidisplay.h"
+#include "utils.h"
+
+/*
+  SDL2 rendering
+  always use RGB565 texture
+  Spectrum -> tmp_screen -> scl_screen -> texture -> (Blit)
+
+*/
+SDL_Window *sdlwin = NULL; /* Hardware screen */
+SDL_Renderer *sdlren = NULL;
+#ifdef USE_WM_ASPECT_X11
+int sdldisplay_use_wm_aspect_hint = 0;
+#endif
+
+static SDL_Texture *sdltxt = NULL;
+static Uint16 tmp_screen[2 * ( DISPLAY_SCREEN_HEIGHT + 4 )][2 * ( DISPLAY_SCREEN_WIDTH  + 3 )]; /* Temporary screen for scalers input */
+static const int tmp_screen_pitch = sizeof( Uint16 ) * ( DISPLAY_SCREEN_WIDTH + 3 );
+static Uint16 *scl_screen = NULL; /* Temporary screen for scalers output */
+static int scl_screen_pitch =  0;
+
+
+static Uint16 tmp_screen_backup[2 * ( DISPLAY_SCREEN_HEIGHT + 4 )][2 * ( DISPLAY_SCREEN_WIDTH  + 3 )];
+
+static SDL_PixelFormat* sdlpix = NULL;
+
+typedef struct {
+  SDL_Texture *t;
+  int w;
+  int h;
+} icon_t;
+
+static icon_t red_cassette, green_cassette;
+static icon_t red_mdr, green_mdr;
+static icon_t red_disk, green_disk;
+
+static ui_statusbar_state sdl_disk_state, sdl_mdr_state, sdl_tape_state;
+static int sdl_status_updated;
+
+static SDL_Color colour_palette[] = {
+  {   0,   0,   0,   0 }, 
+  {   0,   0, 192,   0 }, 
+  { 192,   0,   0,   0 }, 
+  { 192,   0, 192,   0 }, 
+  {   0, 192,   0,   0 }, 
+  {   0, 192, 192,   0 }, 
+  { 192, 192,   0,   0 }, 
+  { 192, 192, 192,   0 }, 
+  {   0,   0,   0,   0 }, 
+  {   0,   0, 255,   0 }, 
+  { 255,   0,   0,   0 }, 
+  { 255,   0, 255,   0 }, 
+  {   0, 255,   0,   0 }, 
+  {   0, 255, 255,   0 }, 
+  { 255, 255,   0,   0 }, 
+  { 255, 255, 255,   0 }
+};
+
+static Uint16 colour_values[16];
+static Uint16 bw_values[16];
+
+/* This is a rule of thumb for the maximum number of rects that can be updated
+   each frame. If more are generated we just update the whole screen */
+#define MAX_UPDATE_RECT 300
+static SDL_Rect updated_rects[MAX_UPDATE_RECT];
+static int num_rects = 0;
+int sdldisplay_force_full_refresh = 1;
+
+/* The size of a 1x1 image in units of
+   DISPLAY_ASPECT WIDTH x DISPLAY_SCREEN_HEIGHT
+   scale * 4, so 2 => 0.5, 6 => 1.5, 4 => 1.0 */
+static int image_scale = -1;
+
+static libspectrum_byte sdldisplay_is_full_screen = 0;
+
+static int image_width;
+static int image_height;
+
+static int timex;
+
+static void init_scalers( void );
+static int sdldisplay_allocate_colours( int numColours, Uint16 *colour_values,
+                                        Uint16 *bw_values );
+
+static int sdldisplay_load_gfx_mode( void );
+
+static void
+init_scalers( void )
+{
+  scaler_register_clear();
+
+  scaler_register( SCALER_NORMAL );
+  scaler_register( SCALER_DOUBLESIZE );
+  scaler_register( SCALER_TRIPLESIZE );
+  scaler_register( SCALER_2XSAI );
+  scaler_register( SCALER_SUPER2XSAI );
+  scaler_register( SCALER_SUPEREAGLE );
+  scaler_register( SCALER_ADVMAME2X );
+  scaler_register( SCALER_ADVMAME3X );
+  scaler_register( SCALER_DOTMATRIX );
+  scaler_register( SCALER_TV2X );
+  scaler_register( SCALER_TV3X );
+  scaler_register( SCALER_PALTV );
+  scaler_register( SCALER_PALTV2X );
+  scaler_register( SCALER_PALTV3X );
+  scaler_register( SCALER_HQ2X );
+  scaler_register( SCALER_HQ3X );
+  if( machine_current->timex ) {
+    scaler_register( SCALER_HALF ); 
+    scaler_register( SCALER_HALFSKIP );
+    scaler_register( SCALER_TIMEXTV );
+    scaler_register( SCALER_TIMEX1_5X );
+  }
+
+  if( scaler_is_supported( current_scaler ) ) {
+    scaler_select_scaler( current_scaler );
+  } else {
+    scaler_select_scaler( SCALER_NORMAL );
+  }
+}
+
+static int
+sdl_convert_icon( SDL_Surface *source, icon_t *icon, int red )
+{
+  SDL_Surface *copy;   /* Copy with altered palette */
+  SDL_Surface *temp;   /* Converted */
+  int i;
+
+  SDL_Color colors[ source->format->palette->ncolors ];
+
+  copy = SDL_ConvertSurface( source, source->format, SDL_SWSURFACE );
+
+  for( i = 0; i < copy->format->palette->ncolors; i++ ) {
+    colors[i].r = red ? copy->format->palette->colors[i].r : 0;
+    colors[i].g = red ? 0 : copy->format->palette->colors[i].g;
+    colors[i].b = 0;
+  }
+
+  SDL_SetPaletteColors( copy->format->palette, colors, 0, i );
+
+  temp = SDL_ConvertSurface( copy, sdlpix, SDL_SWSURFACE );
+  SDL_FreeSurface( copy );
+
+  icon->t = SDL_CreateTextureFromSurface( sdlren, temp );
+  icon->w = temp->w; icon->h = temp->h;
+  SDL_FreeSurface( temp );
+
+  return 0;
+}
+
+static int
+sdl_load_status_icon( const char*filename, icon_t *red, icon_t *green )
+{
+  char path[ PATH_MAX ];
+  SDL_Surface *temp;    /* Copy of image as loaded */
+
+  if( red->t ) {
+    SDL_DestroyTexture( red->t );
+    red->t = NULL;
+  }
+  if( green->t ) {
+    SDL_DestroyTexture( green->t );
+    green->t = NULL;
+  }
+  if( utils_find_file_path( filename, path, UTILS_AUXILIARY_LIB ) ) {
+    fprintf( stderr, "%s: Error getting path for icons\n", fuse_progname );
+    return -1;
+  }
+
+  if((temp = SDL_LoadBMP(path)) == NULL) {
+    fprintf( stderr, "%s: Error loading icon \"%s\" text:%s\n", fuse_progname,
+             path, SDL_GetError() );
+    return -1;
+  }
+
+  if(temp->format->palette == NULL) {
+    fprintf( stderr, "%s: Icon \"%s\" is not paletted\n", fuse_progname, path );
+    return -1;
+  }
+
+  sdl_convert_icon( temp, red, 1 );
+  sdl_convert_icon( temp, green, 0 );
+
+  SDL_FreeSurface( temp );
+
+  return 0;
+}
+
+#ifdef USE_WM_ASPECT_X11
+static void
+wm_setsizehints( void )
+{
+  XSizeHints *sizeHints;
+  SDL_SysWMinfo wminfo;
+
+  sdldisplay_use_wm_aspect_hint = 0;
+
+  SDL_VERSION(&wminfo.version);
+  if( !SDL_GetWindowWMInfo( sdlwin, &wminfo ) || wminfo.subsystem != SDL_SYSWM_X11 ) {
+    return;
+  }
+
+  if( !( sizeHints = XAllocSizeHints() ) ) {
+    fprintf( stderr,"%s: failure allocating memory for X11 WMSizeHints\n", fuse_progname );
+    return;
+  }
+
+  /* Set standard window properties */
+  if( settings_current.aspect_hint ) {
+    sizeHints->flags = PAspect;
+    sizeHints->min_aspect.x = DISPLAY_ASPECT_WIDTH;
+    sizeHints->min_aspect.y = DISPLAY_SCREEN_HEIGHT;
+    sizeHints->max_aspect.x = DISPLAY_ASPECT_WIDTH;
+    sizeHints->max_aspect.y = DISPLAY_SCREEN_HEIGHT;
+    XSetWMNormalHints( wminfo.info.x11.display, wminfo.info.x11.window, sizeHints );
+  }
+  XFree( sizeHints );
+
+  sdldisplay_use_wm_aspect_hint = 1;
+}
+#endif
+
+static void
+sdldisplay_recreate_win_ren( int w, int h )
+{
+  int x, y;
+  if( sdlwin ) {
+    SDL_GetWindowPosition( sdlwin, &x, &y );
+    SDL_DestroyRenderer( sdlren );
+    sdlren = NULL;
+    SDL_DestroyWindow( sdlwin );
+    sdlwin = NULL;
+  } else {
+    x = y = SDL_WINDOWPOS_UNDEFINED;
+  }
+  sdlwin = SDL_CreateWindow( "Fuse", x, y, w, h, SDL_WINDOW_RESIZABLE);
+  if( !sdlwin ) {
+    fprintf( stderr, "%s: couldn't create SDL2 window\n", fuse_progname );
+    fuse_abort();
+  }
+  sdlren =  SDL_CreateRenderer(sdlwin, -1, 0);
+  if( !sdlren ) {
+    fprintf( stderr, "%s: couldn't create SDL2 renderer\n", fuse_progname );
+    fuse_abort();
+  }
+#ifdef USE_WM_ASPECT_X11
+  wm_setsizehints();
+#endif
+
+/* If we place this before wm_setsizehints(), there is no effect (on X11) */
+  SDL_SetWindowMinimumSize( sdlwin, w, h );
+
+  sdlpix = SDL_AllocFormat( SDL_PIXELFORMAT_RGB565 );
+  sdldisplay_allocate_colours( 16, colour_values, bw_values );
+  scaler_select_bitformat( 565 ); /* SDL2 always use 565 */
+
+  sdl_load_status_icon( "cassette.bmp", &red_cassette, &green_cassette );
+  sdl_load_status_icon( "microdrive.bmp", &red_mdr, &green_mdr );
+  sdl_load_status_icon( "plus3disk.bmp", &red_disk, &green_disk );
+
+}
+
+int
+uidisplay_init( int width, int height )
+{
+
+  image_width = width;
+  image_height = height;
+
+  SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, settings_current.sdl_scale_quality ? settings_current.sdl_scale_quality : "2" );
+
+  timex = machine_current->timex;
+
+  init_scalers();
+
+  if( !sdlwin ) {
+    red_cassette.t = green_cassette.t = NULL;
+    red_mdr.t = green_mdr.t = NULL;
+    red_disk.t = green_disk.t = NULL;
+    sdldisplay_recreate_win_ren( 0, 0 );
+  }
+
+  if ( scaler_select_scaler( current_scaler ) )
+    scaler_select_scaler( SCALER_NORMAL );
+
+  image_scale = 0; /* force load_gfx_mode() */
+  if( sdldisplay_load_gfx_mode() ) return 1;
+  /* We can now output error messages to our output device */
+  display_ui_initialised = 1;
+
+  sdl_load_status_icon( "cassette.bmp", &red_cassette, &green_cassette );
+  sdl_load_status_icon( "microdrive.bmp", &red_mdr, &green_mdr );
+  sdl_load_status_icon( "plus3disk.bmp", &red_disk, &green_disk );
+
+  return 0;
+}
+
+static int
+sdldisplay_allocate_colours( int numColours, Uint16 *colour_values,
+                             Uint16 *bw_values )
+{
+  int i;
+  Uint8 red, green, blue, grey;
+
+  for( i = 0; i < numColours; i++ ) {
+
+      red = colour_palette[i].r;
+    green = colour_palette[i].g;
+     blue = colour_palette[i].b;
+
+    /* Addition of 0.5 is to avoid rounding errors */
+    grey = ( 0.299 * red + 0.587 * green + 0.114 * blue ) + 0.5;
+
+    colour_values[i] = SDL_MapRGB( sdlpix,  red, green, blue );
+    bw_values[i]     = SDL_MapRGB( sdlpix, grey,  grey, grey );
+  }
+
+  return 0;
+}
+
+/**
+ ** called from uidisplay_init()->init_scalers(), uidisplay_init(), scaler_select_scaler()
+**/
+static int
+sdldisplay_load_gfx_mode( void )
+{
+  int old_image_scale = image_scale;
+
+  image_scale = 4 * scaler_get_scaling_factor( current_scaler );
+  if( old_image_scale != image_scale ) {
+    /* Free the old pixels */
+    if( sdltxt ) {
+      SDL_DestroyTexture( sdltxt );
+      sdltxt = NULL;
+    }
+    if( scl_screen ) {
+      free( scl_screen );
+      scl_screen = NULL;
+    }
+    if( sdlwin ) { /* SDL2 windows and Renderer... initialised */
+      sdldisplay_recreate_win_ren( image_width * image_scale >> 2,
+                                   image_height * image_scale >> 2 );
+
+      /* Create the temp screen and texture used for the graphics in 16 bit before scaling */
+      scl_screen = malloc( image_width  * image_height * sizeof( Uint16 ) *
+                                         image_scale * image_scale >> 4);
+
+      if( !scl_screen ) {
+        fprintf( stderr, "%s: couldn't create SDL texture\n", fuse_progname );
+        fuse_abort();
+      }
+      scl_screen_pitch = image_width * sizeof( Uint16 ) * image_scale >> 2;
+
+      sdltxt = SDL_CreateTexture(sdlren,
+                                 SDL_PIXELFORMAT_RGB565,
+                                 SDL_TEXTUREACCESS_STREAMING,
+                                 image_width * image_scale >> 2,
+                                 image_height * image_scale >> 2 );
+
+      if( !sdltxt ) {
+        fprintf( stderr, "%s: couldn't create SDL texture (%dx%d)\n", fuse_progname,
+                 image_width * image_scale >> 2, image_height * image_scale >> 2 );
+        fuse_abort();
+      }
+
+      SDL_RenderSetLogicalSize( sdlren,
+                                 image_width * image_scale >> 2,
+                                 image_height * image_scale >> 2 );
+
+    }
+  }
+
+  if( settings_current.full_screen ) {
+/*      if( !SDL_SetWindowFullscreen( sdlwin, SDL_WINDOW_FULLSCREEN ) ) */
+      SDL_SetWindowFullscreen( sdlwin, SDL_WINDOW_FULLSCREEN_DESKTOP );
+  } else {
+    SDL_SetWindowFullscreen( sdlwin, 0 );
+  }
+  sdldisplay_is_full_screen =
+          settings_current.full_screen = !!(SDL_GetWindowFlags(sdlwin) &
+                                  (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP ) );
+
+
+  /* Redraw the entire screen... */
+  sdldisplay_force_full_refresh = 1;
+  display_refresh_all();
+
+  return 0;
+}
+
+int
+uidisplay_hotswap_gfx_mode( void )
+{
+  fuse_emulation_pause();
+
+  /* Setup the new GFX mode */
+  if( sdldisplay_load_gfx_mode() ) return 1;
+
+  /* Mac OS X resets the state of the cursor after a switch to full screen
+     mode */
+  if ( settings_current.full_screen || ui_mouse_grabbed ) {
+    SDL_ShowCursor( SDL_DISABLE );
+    SDL_WarpMouseInWindow( sdlwin, 128, 128 );
+  } else {
+    SDL_ShowCursor( SDL_ENABLE );
+  }
+
+  fuse_emulation_unpause();
+
+  return 0;
+}
+
+void
+uidisplay_frame_save( void )
+{
+  memcpy( tmp_screen_backup, tmp_screen, sizeof( tmp_screen ) );
+}
+
+void
+uidisplay_frame_restore( void )
+{
+  memcpy( tmp_screen, tmp_screen_backup, sizeof( tmp_screen ) );
+  sdldisplay_force_full_refresh = 1;
+}
+
+static void
+sdl_blit_icon( icon_t *icon, SDL_Rect *r)
+{
+
+  if( timex ) {
+    r->x<<=1;
+    r->y<<=1;
+    r->w<<=1;
+    r->h<<=1;
+  }
+
+  r->x = r->x * image_scale >> 2;
+  r->y = r->y * image_scale >> 2;
+  r->w = r->w * image_scale >> 2;
+  r->h = r->h * image_scale >> 2;
+  r->x++;
+  r->y++;
+
+/* SDL2 renderer scale our icon... */
+  SDL_RenderCopy( sdlren, icon->t, NULL, r);
+
+  return;
+}
+
+static void
+sdl_icon_overlay( int tmp_screen_pitch, Uint32 dstPitch )
+{
+  SDL_Rect r = { 243, 218, red_disk.w, red_disk.h };
+
+  switch( sdl_disk_state ) {
+  case UI_STATUSBAR_STATE_ACTIVE:
+    sdl_blit_icon( &green_disk, &r );
+    break;
+  case UI_STATUSBAR_STATE_INACTIVE:
+    sdl_blit_icon( &red_disk, &r );
+    break;
+  case UI_STATUSBAR_STATE_NOT_AVAILABLE:
+    break;
+  }
+
+  r.x = 264;
+  r.y = 218;
+  r.w = red_mdr.w;
+  r.h = red_mdr.h;
+
+  switch( sdl_mdr_state ) {
+  case UI_STATUSBAR_STATE_ACTIVE:
+    sdl_blit_icon( &green_mdr, &r );
+    break;
+  case UI_STATUSBAR_STATE_INACTIVE:
+    sdl_blit_icon( &red_mdr, &r );
+    break;
+  case UI_STATUSBAR_STATE_NOT_AVAILABLE:
+    break;
+  }
+
+  r.x = 285;
+  r.y = 220;
+  r.w = red_cassette.w;
+  r.h = red_cassette.h;
+
+  switch( sdl_tape_state ) {
+  case UI_STATUSBAR_STATE_ACTIVE:
+    sdl_blit_icon( &green_cassette, &r );
+    break;
+  case UI_STATUSBAR_STATE_INACTIVE:
+  case UI_STATUSBAR_STATE_NOT_AVAILABLE:
+    sdl_blit_icon( &red_cassette, &r );
+    break;
+  }
+
+  sdl_status_updated = 0;
+}
+
+/* Set one pixel in the display */
+void
+uidisplay_putpixel( int x, int y, int colour )
+{
+  libspectrum_word *dest_base, *dest;
+  Uint16 *palette_values = settings_current.bw_tv ? bw_values :
+                           colour_values;
+
+  Uint16 palette_colour = palette_values[ colour ];
+
+  if( machine_current->timex ) {
+    x <<= 1; y <<= 1;
+    dest_base = dest =
+      (libspectrum_word*)( (libspectrum_byte*)tmp_screen +
+                           (x+1) * 2 +
+                           (y+1) * tmp_screen_pitch);
+
+    *(dest++) = palette_colour;
+    *(dest++) = palette_colour;
+    dest = (libspectrum_word*)
+      ( (libspectrum_byte*)dest_base + tmp_screen_pitch);
+    *(dest++) = palette_colour;
+    *(dest++) = palette_colour;
+  } else {
+    dest =
+      (libspectrum_word*)( (libspectrum_byte*)tmp_screen +
+                           (x+1) * 2 +
+                           (y+1) * tmp_screen_pitch);
+
+    *dest = palette_colour;
+  }
+}
+
+/* Print the 8 pixels in `data' using ink colour `ink' and paper
+   colour `paper' to the screen at ( (8*x) , y ) */
+void
+uidisplay_plot8( int x, int y, libspectrum_byte data,
+	         libspectrum_byte ink, libspectrum_byte paper )
+{
+  libspectrum_word *dest;
+  Uint16 *palette_values = settings_current.bw_tv ? bw_values :
+                           colour_values;
+
+  Uint16 palette_ink = palette_values[ ink ];
+  Uint16 palette_paper = palette_values[ paper ];
+
+  if( machine_current->timex ) {
+    int i;
+    libspectrum_word *dest_base;
+
+    x <<= 4; y <<= 1;
+
+    dest_base =
+      (libspectrum_word*)( (libspectrum_byte*)tmp_screen +
+                           (x+1) * 2 +
+                           (y+1) * tmp_screen_pitch);
+
+    for( i=0; i<2; i++ ) {
+      dest = dest_base;
+
+      *(dest++) = ( data & 0x80 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x80 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x40 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x40 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x20 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x20 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x10 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x10 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x08 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x08 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x04 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x04 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x02 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x02 ) ? palette_ink : palette_paper;
+      *(dest++) = ( data & 0x01 ) ? palette_ink : palette_paper;
+      *dest     = ( data & 0x01 ) ? palette_ink : palette_paper;
+
+      dest_base = (libspectrum_word*)
+        ( (libspectrum_byte*)dest_base + tmp_screen_pitch);
+    }
+  } else {
+    x <<= 3;
+
+    dest =
+      (libspectrum_word*)( (libspectrum_byte*)tmp_screen +
+                           (x+1) * 2 +
+                           (y+1) * tmp_screen_pitch);
+
+    *(dest++) = ( data & 0x80 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x40 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x20 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x10 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x08 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x04 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x02 ) ? palette_ink : palette_paper;
+    *dest     = ( data & 0x01 ) ? palette_ink : palette_paper;
+  }
+}
+
+/* Print the 16 pixels in `data' using ink colour `ink' and paper
+   colour `paper' to the screen at ( (16*x) , y ) */
+void
+uidisplay_plot16( int x, int y, libspectrum_word data,
+		  libspectrum_byte ink, libspectrum_byte paper )
+{
+  libspectrum_word *dest_base, *dest;
+  int i;
+  Uint16 *palette_values = settings_current.bw_tv ? bw_values :
+                           colour_values;
+  Uint16 palette_ink = palette_values[ ink ];
+  Uint16 palette_paper = palette_values[ paper ];
+  x <<= 4; y <<= 1;
+
+  dest_base =
+    (libspectrum_word*)( (libspectrum_byte*)tmp_screen +
+                         (x+1) * 2 +
+                         (y+1) * tmp_screen_pitch);
+
+  for( i=0; i<2; i++ ) {
+    dest = dest_base;
+
+    *(dest++) = ( data & 0x8000 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x4000 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x2000 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x1000 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0800 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0400 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0200 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0100 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0080 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0040 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0020 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0010 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0008 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0004 ) ? palette_ink : palette_paper;
+    *(dest++) = ( data & 0x0002 ) ? palette_ink : palette_paper;
+    *dest     = ( data & 0x0001 ) ? palette_ink : palette_paper;
+
+    dest_base = (libspectrum_word*)
+      ( (libspectrum_byte*)dest_base + tmp_screen_pitch);
+  }
+}
+
+void
+uidisplay_frame_end( void )
+{
+  SDL_Rect *r;
+  SDL_Rect *last_rect;
+
+  /* We check for a switch to fullscreen here to give systems with a
+     windowed-only UI a chance to free menu etc. resources before
+     the switch to fullscreen (e.g. Mac OS X) */
+  if( sdldisplay_is_full_screen != settings_current.full_screen &&
+      uidisplay_hotswap_gfx_mode() ) {
+    fprintf( stderr, "%s: Error switching to fullscreen\n", fuse_progname );
+    fuse_abort();
+  }
+
+  /* Force a full redraw if requested */
+  if ( sdldisplay_force_full_refresh ) {
+    num_rects = 1;
+
+    updated_rects[0].x = 0;
+    updated_rects[0].y = 0;
+    updated_rects[0].w = image_width;
+    updated_rects[0].h = image_height;
+  }
+
+  if ( !(ui_widget_level >= 0) && num_rects == 0 && !sdl_status_updated )
+    return;
+
+  last_rect = updated_rects + num_rects;
+
+  for( r = updated_rects; r != last_rect; r++ ) {
+    libspectrum_byte *pixel_data;
+
+    int dst_y = r->y * image_scale >> 2;
+    int dst_h = r->h;
+
+    scaler_proc16(
+      (libspectrum_byte*)tmp_screen +
+                        (r->x+1) * 2 +
+	                (r->y+1) * tmp_screen_pitch,
+      tmp_screen_pitch, (pixel_data = 
+      (libspectrum_byte*)scl_screen +
+	                 (int)(r->x * image_scale >> 1) +
+			 dst_y * scl_screen_pitch),
+      scl_screen_pitch, r->w, dst_h
+    );
+
+    /* Adjust rects for the destination rect size */
+    r->x = r->x * image_scale >> 2;
+    r->y = dst_y;
+    r->w = r->w * image_scale >> 2;
+    r->h = dst_h * image_scale >> 2;
+  /* Blit our changes to the texture */
+    SDL_UpdateTexture( sdltxt, r, pixel_data, scl_screen_pitch );
+  }
+
+  updated_rects[0].x = 0;
+  updated_rects[0].y = 0;
+  updated_rects[0].w = image_width * image_scale >> 2;
+  updated_rects[0].h = image_height * image_scale >> 2;
+  SDL_RenderCopy( sdlren, sdltxt, updated_rects, updated_rects );
+
+  if ( settings_current.statusbar )
+    sdl_icon_overlay( tmp_screen_pitch, scl_screen_pitch );
+
+  SDL_RenderPresent( sdlren );
+
+  num_rects = 0;
+  sdldisplay_force_full_refresh = 0;
+}
+
+void
+uidisplay_area( int x, int y, int width, int height )
+{
+  if ( sdldisplay_force_full_refresh )
+    return;
+
+  if( num_rects == MAX_UPDATE_RECT ) {
+    sdldisplay_force_full_refresh = 1;
+    return;
+  }
+
+  /* Extend the dirty region by 1 pixel for scalers
+     that "smear" the screen, e.g. 2xSAI */
+  if( scaler_flags & SCALER_FLAGS_EXPAND )
+    scaler_expander( &x, &y, &width, &height, image_width, image_height );
+
+  updated_rects[num_rects].x = x;
+  updated_rects[num_rects].y = y;
+  updated_rects[num_rects].w = width;
+  updated_rects[num_rects].h = height;
+
+  num_rects++;
+}
+
+int
+uidisplay_end( void )
+{
+  int i;
+
+  display_ui_initialised = 0;
+
+  for( i=0; i<2; i++ ) {
+    if ( red_cassette.t ) {
+      SDL_DestroyTexture( red_cassette.t ); red_cassette.t = NULL;
+    }
+    if ( green_cassette.t ) {
+      SDL_DestroyTexture( green_cassette.t ); green_cassette.t = NULL;
+    }
+    if ( red_mdr.t ) {
+      SDL_DestroyTexture( red_mdr.t ); red_mdr.t = NULL;
+    }
+    if ( green_mdr.t ) {
+      SDL_DestroyTexture( green_mdr.t ); green_mdr.t = NULL;
+    }
+    if ( red_disk.t ) {
+      SDL_DestroyTexture( red_disk.t ); red_disk.t = NULL;
+    }
+    if ( green_disk.t ) {
+      SDL_DestroyTexture( green_disk.t ); green_disk.t = NULL;
+    }
+  }
+
+  return 0;
+}
+
+/* The statusbar handling function */
+int
+ui_statusbar_update( ui_statusbar_item item, ui_statusbar_state state )
+{
+  switch( item ) {
+
+  case UI_STATUSBAR_ITEM_DISK:
+    sdl_disk_state = state;
+    sdl_status_updated = 1;
+    return 0;
+
+  case UI_STATUSBAR_ITEM_PAUSED:
+    /* We don't support pausing this version of Fuse */
+    return 0;
+
+  case UI_STATUSBAR_ITEM_TAPE:
+    sdl_tape_state = state;
+    sdl_status_updated = 1;
+    return 0;
+
+  case UI_STATUSBAR_ITEM_MICRODRIVE:
+    sdl_mdr_state = state;
+    sdl_status_updated = 1;
+    return 0;
+
+  case UI_STATUSBAR_ITEM_MOUSE:
+    /* We don't support showing a grab icon */
+    return 0;
+
+  }
+
+  ui_error( UI_ERROR_ERROR, "Attempt to update unknown statusbar item %d",
+            item );
+  return 1;
+}
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdl2keyboard.h
+++ b/ui/sdl/sdl2keyboard.h
@@ -0,0 +1,39 @@
+/* sdl2keyboard.h: macros for dealing with SDL-SDL2 SDLK_.. difference
+   Copyright (c) 2014 Gergely Szasz
+
+   $Id: $
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   E-mail: szaszg@hu.inter.net
+
+*/
+
+#ifndef FUSE_SDL2KEYBOARD_H
+#define FUSE_SDL2KEYBOARD_H
+
+#include <config.h>
+
+#ifdef UI_SDL2
+#define SDLK_LMETA SDLK_LGUI
+#define SDLK_RMETA SDLK_RGUI
+
+#define SDLK_LSUPER -1
+#define SDLK_RSUPER -1
+#endif
+
+#endif			/* #ifndef FUSE_SDLKEYBOARD_H */
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdldisplay.h
+++ b/ui/sdl/sdldisplay.h
@@ -24,6 +24,17 @@
 #ifndef FUSE_SDLDISPLAY_H
 #define FUSE_SDLDISPLAY_H
 
+#ifdef UI_SDL
 extern SDL_Surface *sdldisplay_gc;    /* Hardware screen */
+#endif
+
+#ifdef UI_SDL2
+extern SDL_Window *sdlwin;    /* Hardware screen */
+extern SDL_Renderer *sdlren;
+extern int sdldisplay_force_full_refresh;
+#ifdef USE_WM_ASPECT_X11
+extern int sdldisplay_use_wm_aspect_hint;
+#endif
+#endif
 
 #endif			/* #ifndef FUSE_SDLDISPLAY_H */
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdljoystick.c
+++ b/ui/sdl/sdljoystick.c
@@ -53,7 +53,7 @@
 {
   int error, retval;
 
-#ifdef UI_SDL
+#if defined UI_SDL || defined UI_SDL2
   error = SDL_InitSubSystem( SDL_INIT_JOYSTICK );
 #else
   /* Other UIs could handle joysticks by the SDL library */
@@ -109,7 +109,7 @@
   /* No action needed in SDL UI; joysticks already handled by the SDL events
      system */
 
-#ifndef UI_SDL
+#if !defined UI_SDL && !defined UI_SDL2
   SDL_Event event;
 
   while( SDL_PollEvent( &event ) ) {
@@ -245,7 +245,7 @@
 
   }
 
-#ifdef UI_SDL
+#if defined UI_SDL || defined UI_SDL2
   SDL_QuitSubSystem( SDL_INIT_JOYSTICK );
 #else
   SDL_Quit();
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdlkeyboard.c
+++ b/ui/sdl/sdlkeyboard.c
@@ -65,24 +65,71 @@
   for( ptr3 = (keysyms_map_t *)unicode_keysyms_map; ptr3->ui; ptr3++ )
     g_hash_table_insert( unicode_keysyms_hash, &( ptr3->ui ),
                          &( ptr3->fuse ) );
-
+#ifdef UI_SDL2
+  SDL_StartTextInput();
+#endif
+#ifdef UI_SDL
   SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
+#endif
 }
 
 void
 sdlkeyboard_end(void)
 {
+#ifdef UI_SDL2
+  SDL_StopTextInput();
+#endif
   g_hash_table_destroy( unicode_keysyms_hash );
 }
 
+#ifdef UI_SDL2
+void
+sdlkeyboard_text( SDL_TextInputEvent *textevent )
+{
+  input_key unicode_keysym;
+  input_event_t fuse_event;
+
+  /* Currently unicode_keysyms_map contains ASCII character keys */ 
+  unicode_keysym = unicode_keysyms_remap( textevent->text[0] );
+
+  if( unicode_keysym == INPUT_KEY_NONE )
+    return;
+
+  fuse_event.type = INPUT_EVENT_KEYPRESS;
+  fuse_event.types.key.native_key = unicode_keysym;
+  fuse_event.types.key.spectrum_key = INPUT_KEY_NONE;
+
+  input_event( &fuse_event );
+}
+#endif
+
 void
 sdlkeyboard_keypress( SDL_KeyboardEvent *keyevent )
 {
-  input_key fuse_keysym, unicode_keysym;
+  input_key fuse_keysym;
+#ifdef UI_SDL
+  input_key unicode_keysym;
+#endif
   input_event_t fuse_event;
 
+#ifdef UI_SDL2
+/* SDL2 uses TextInput for widget system... */
+  if( ui_widget_level >= 0 && 
+      keyevent->keysym.sym >= SDLK_SPACE && 
+       keyevent->keysym.sym <= SDLK_z)
+    return;
+#endif
+
   fuse_keysym = keysyms_remap( keyevent->keysym.sym );
 
+#ifdef UI_SDL2
+  if( fuse_keysym == INPUT_KEY_NONE )
+    return;
+
+  fuse_event.types.key.native_key = fuse_keysym;
+#endif
+
+#ifdef UI_SDL
   /* Currently unicode_keysyms_map contains ASCII character keys */
   if( ( keyevent->keysym.unicode & 0xFF80 ) == 0 ) 
     unicode_keysym = unicode_keysyms_remap( keyevent->keysym.unicode );
@@ -92,11 +139,13 @@
   if( fuse_keysym == INPUT_KEY_NONE && unicode_keysym == INPUT_KEY_NONE )
     return;
 
-  fuse_event.type = INPUT_EVENT_KEYPRESS;
   if( unicode_keysym == INPUT_KEY_NONE )
     fuse_event.types.key.native_key = fuse_keysym;
   else
     fuse_event.types.key.native_key = unicode_keysym;
+#endif
+
+  fuse_event.type = INPUT_EVENT_KEYPRESS;
   fuse_event.types.key.spectrum_key = fuse_keysym;
 
   input_event( &fuse_event );
@@ -108,6 +157,14 @@
   input_key fuse_keysym;
   input_event_t fuse_event;
 
+#ifdef UI_SDL2
+/* SDL2 uses TextInput for widget system... */
+  if( ui_widget_level >= 0 && 
+      keyevent->keysym.sym >= SDLK_SPACE && 
+       keyevent->keysym.sym <= SDLK_z)
+    return;
+#endif
+
   fuse_keysym = keysyms_remap( keyevent->keysym.sym );
 
   if( fuse_keysym == INPUT_KEY_NONE ) return;
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdlkeyboard.h
+++ b/ui/sdl/sdlkeyboard.h
@@ -27,6 +27,9 @@
 
 void sdlkeyboard_init(void);
 void sdlkeyboard_end(void);
+#ifdef UI_SDL2
+void sdlkeyboard_text( SDL_TextInputEvent *textevent );
+#endif
 void sdlkeyboard_keypress(SDL_KeyboardEvent *keyevent);
 void sdlkeyboard_keyrelease(SDL_KeyboardEvent *keyevent);
 
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/sdl/sdlui.c
+++ b/ui/sdl/sdlui.c
@@ -59,10 +59,11 @@
   error = SDL_Init( SDL_INIT_VIDEO );
   if ( error )
     return error;
-
+#ifdef UI_SDL
 #ifndef __MORPHOS__
   SDL_EnableUNICODE( 1 );
 #endif				/* #ifndef __MORPHOS__ */
+#endif
 
   sdlkeyboard_init();
 
@@ -84,7 +85,12 @@
     case SDL_KEYUP:
       sdlkeyboard_keyrelease( &(event.key) );
       break;
-
+#ifdef UI_SDL2
+    case SDL_TEXTINPUT:
+      if( ui_widget_level >= 0 )
+        sdlkeyboard_text( &(event.text) );
+      break;
+#endif
     case SDL_MOUSEBUTTONDOWN:
       ui_mouse_button( event.button.button, 1 );
       break;
@@ -95,7 +101,12 @@
       if( ui_mouse_grabbed ) {
         ui_mouse_motion( event.motion.x - 128, event.motion.y - 128 );
         if( event.motion.x != 128 || event.motion.y != 128 )
+#ifdef UI_SDL2
+          SDL_WarpMouseInWindow( sdlwin, 128, 128 );
+#endif
+#ifdef UI_SDL
           SDL_WarpMouse( 128, 128 );
+#endif
       }	
       break;
 
@@ -121,6 +132,36 @@
       menu_file_exit(0);
       fuse_emulation_unpause();
       break;
+#ifdef UI_SDL2
+    case SDL_WINDOWEVENT:
+      if( event.window.event == SDL_WINDOWEVENT_EXPOSED )
+        display_refresh_all();
+      if( event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED )
+        ui_mouse_resume();
+      if( event.window.event == SDL_WINDOWEVENT_FOCUS_LOST )
+        ui_mouse_suspend();
+      if( event.window.event == SDL_WINDOWEVENT_RESIZED ) {
+        if( settings_current.aspect_hint
+#ifdef USE_WM_ASPECT_X11
+            && !sdldisplay_use_wm_aspect_hint
+#endif
+        ) {
+
+          int aspect = 3 * event.window.data1 - 4 * event.window.data2;
+
+          if( aspect < 0 ) /* too high */
+            SDL_SetWindowSize( sdlwin, event.window.data1, 3 * event.window.data1 / 4 );
+          else if( aspect > 0 ) /* too wide */
+            SDL_SetWindowSize( sdlwin, 4 * event.window.data2 / 3, event.window.data2 );
+        }
+        SDL_RenderClear( sdlren );
+        sdldisplay_force_full_refresh = 1;
+        if( ui_widget_level >= 0 ) {
+          uidisplay_frame_end();
+        }
+      }
+#endif
+#ifdef UI_SDL
     case SDL_VIDEOEXPOSE:
       display_refresh_all();
       break;
@@ -128,6 +169,7 @@
       if( event.active.state & SDL_APPINPUTFOCUS ) {
 	if( event.active.gain ) ui_mouse_resume(); else ui_mouse_suspend();
       }
+#endif
       break;
     default:
       break;
@@ -164,8 +206,12 @@
   snprintf( buffer, 15, "%s - %3.0f%%", fuse, speed );
 
   /* FIXME: Icon caption should be snapshot name? */
+#ifdef UI_SDL2
+  SDL_SetWindowTitle( sdlwin, buffer );
+#endif
+#ifdef UI_SDL
   SDL_WM_SetCaption( buffer, fuse );
-
+#endif
   return 0;
 }
 
@@ -173,11 +219,24 @@
 ui_mouse_grab( int startup )
 {
   if( settings_current.full_screen ) {
+#ifdef UI_SDL2
+    SDL_WarpMouseInWindow( sdlwin, 128, 128 );
+#endif
+#ifdef UI_SDL
     SDL_WarpMouse( 128, 128 );
+#endif
     return 1;
   }
   if( startup ) return 0;
 
+#ifdef UI_SDL2
+  if( SDL_SetRelativeMouseMode(SDL_TRUE) < 0) {
+    ui_error( UI_ERROR_WARNING, "Mouse grab failed" );
+    return 0;
+  }
+  return 1;
+#endif
+#ifdef UI_SDL
   switch( SDL_WM_GrabInput( SDL_GRAB_ON ) ) {
   case SDL_GRAB_ON:
   case SDL_GRAB_FULLSCREEN:
@@ -188,6 +247,7 @@
     ui_error( UI_ERROR_WARNING, "Mouse grab failed" );
     return 0;
   }
+#endif
 }
 
 int
@@ -195,7 +255,12 @@
 {
   if( settings_current.full_screen ) return !suspend;
 
+#ifdef UI_SDL2
+  SDL_SetRelativeMouseMode(SDL_FALSE);
+#endif
+#ifdef UI_SDL
   SDL_WM_GrabInput( SDL_GRAB_OFF );
   SDL_ShowCursor( SDL_ENABLE );
+#endif
   return 0;
 }
By Marc Serdeliuc
https://github.com/serdeliuk

--- a/ui/widget/widget.c
+++ b/ui/widget/widget.c
@@ -694,6 +694,7 @@
 };
 
 #ifndef UI_SDL
+#ifndef UI_SDL2
 #ifndef UI_X
 /* The statusbar handling functions */
 /* TODO: make these do something useful */
@@ -709,6 +710,7 @@
   return 0;
 }
 #endif
+#endif
 #endif                          /* #ifndef UI_SDL */
 
 /* Tape browser update function. The dialog box is created every time it
@@ -827,6 +829,11 @@
     menu_file_exit( 0 );
     fuse_emulation_unpause();
     break;
+  case INPUT_KEY_F11:
+    fuse_emulation_pause();
+    menu_options_fullscreen( 0 );
+    fuse_emulation_unpause();
+    break;
 
   default: break;		/* Remove gcc warning */
 
